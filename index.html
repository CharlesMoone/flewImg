<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no" />
    <title>基于flex的图片布局</title>
    <style>
        body {
            margin: 0;
            display: flex;
            display: -webkit-flex;
            flex-wrap: wrap;
        }
        div {
            display: inherit;
            flex-wrap: wrap;
            align-content: flex-start;
            padding: 10px 0.5%;
        }
        @media screen and (max-width: 576px) {
            div {
                width: 49%;
            }
        }
        @media screen and (max-width: 864px) and (min-width: 576px) {
            div {
                width: 32.33%;
            }
        }
        @media screen and (max-width: 1152px) and (min-width: 864px) {
            div {
                width: 24%;
            }
        }
        @media screen and (max-width: 1440px) and (min-width: 1152px) {
            div {
                width: 19%;
            }
        }
        @media screen and (min-width: 1440px) {
            div {
                width: 15.66%;
            }
        }
        div img {
            width: 100%;
            height: 100%;
            margin: 0 0 10px;
        }
    </style>
</head>
<body>
<script src="compatible.js"></script>
<script>
    /**
     * 图片类
     * @returns {ImageClass} 安全模式
     * @constructor 指向自己
     */
    var ImageClass = function (pullNumber) {
        if (this instanceof ImageClass) {
            this.constructor = this;            //构造函数指向自己
            this.div = new Array(6);            //创建一个div的容器,最大为6个
            this.img = [];                      //创建一个img的容器,不设上限
            //创建一个状态储存器,分别对应2,3,4,5,6个div
            this.widthStatus = [false, false, false, false, false];
            this.number = 0;                    //储存总图片数量
            this.pullNumber = pullNumber || 20; //储存每次申请图片数量,默认为20
            this.pullRequest = true;            //变更对新图片申请的状态
            this.divNumber = 0;                 //保存当前width对应div的数量
            this.target = null;                 //保存要插入的目标
        } else {
            return new ImageClass();
        }
    };

    /**
     * 原型方法
     * @type {{
     * init: ImageClass.init,                   初始化
     * widthCheck: ImageClass.widthCheck,       宽度检查
     * resize: ImageClass.resize                宽度达到标准进行resize
     * }}
     */
    ImageClass.prototype = {
        init: function () {
            for (var i = 0; i < 6; i++) {
                this.div[i] = {
                    dom: document.createElement('DIV'),
                    length: 0
                };
            }
            this.pull();
        },
        widthCheck: function (width, target) {
            try {
                this.target = target || document.getElementsByTagName('body')[0];
            } catch (e) {console.error(e)}
            if (width >= 1440 && !this.widthStatus[4]) {
                this.resize(6);
            } else if (width < 1440 && width >= 1152 && !this.widthStatus[3]) {
                this.resize(5);
            } else if (width < 1152 && width >= 864 && !this.widthStatus[2]) {
                this.resize(4);
            } else if (width < 864 && width >= 576 && !this.widthStatus[1]) {
                this.resize(3);
            } else if (width < 576 && !this.widthStatus[0]) {
                this.resize(2);
            }
        },
        resize: function (divNumber) {
            this.divNumber = divNumber;
            this.target.innerHTML = null;
            this.widthStatus = [false, false, false, false, false];
            this.widthStatus[divNumber-2] = true;
            this.resetImg();
        },
        resetImg : function () {
            for (var i = 0; i < this.divNumber; i ++) {
                this.target.appendChild(this.div[i].dom);
            }
        },
        setImg: function (img) {
            var i = 0, temp = 0;
            for (; i < this.divNumber; i ++) {
                if (this.div[temp].length > this.div[i].length) {
                    temp = i;
                }
            }
            this.div[temp].dom.appendChild(img);
            this.div[temp].length += img.height;
        },
        pull: function () {
            if (!this.pullRequest) return ;
            console.log('pull success!');
            this.pullRequest = false;
            var max = this.number + this.pullNumber, count = 0, that = this;
            for (; this.number < max; this.number ++) {
                this.img[this.number] = document.createElement('IMG');
                this.img[this.number].src = 'http://placehold.it/' + (100 + Math.floor(Math.random() * 100)) + 'x' + (Math.floor(Math.random() * 100) + 100);
//                this.img[this.number].src = 'http://lorempixel.com/' + (100 + Math.floor(Math.random() * 100)) + '/' + (Math.floor(Math.random() * 100) + 100) + "?id=" + this.number;
                this.img[this.number].onload = this.img[this.number].onerror = function () {
                    that.setImg(this);
                    if (++count == that.pullNumber) {
                        that.pullRequest = true;
                    }
                };
            }
        }
    };

    window.onload = function () {
        var image = new ImageClass();
        image.init();
        image.widthCheck(document.body.clientWidth);

        window.onresize = function (e) {
            image.widthCheck(e.currentTarget.innerWidth);
        };

        window.onscroll = function () {
            if (compatible.getScrollTop() + compatible.getWindowHeight() == compatible.getScrollHeight()) {
                image.pull();
            }
        };
    };

</script>
</body>
</html>